package game;

/*
CLASS: YourGameNameoids
DESCRIPTION: Extending Game, YourGameName is all in the paint method.
NOTE: This class is the metaphorical "main method" of your program,
      it is your control center.

 */
import java.awt.*;

public class ShipGame extends Game {
	private static final long serialVersionUID = 1L;

	static int counter = 0;


	Ship user;
	Tokens[] tokensGood, tokensBad;
	Obstacle[] obstacles;
	Score score;
	EndGame e;

	public ShipGame() {
		super("ShipGame!",1000,1000);
		this.setFocusable(true);
		this.requestFocus();

		tokensGood = generateTokens();
		tokensBad = generateTokens();
		obstacles = generateObstacle();

		Point [] ship = new Point[7]; 
		ship[0] = new Point(0,0);
		ship[1] = new Point(45,0);
		ship[2] = new Point(0,20);
		ship[3] = new Point(45,20);
		ship[4] = new Point(35,20);
		ship[5] = new Point(35,5);
		ship[6] = new Point(45,5);


		user = new Ship(ship, new Point(15, 485), 0);

		this.addKeyListener(user);
		score = new Score();
		e = new EndGame();

	}

	public void paint(Graphics brush) {
		brush.setColor(Color.black);
		brush.fillRect(0,0,width,height);

		// sample code for printing message for debugging
		// counter is incremented and this message printed
		// each time the canvas is repainted
		counter++;
		e.isGameOver();
		if(!e.getGameOver()) {
			brush.setColor(Color.white);
			brush.drawString("Time passed: " + counter/100,10,10);
			user.move();
			user.paint(brush);
			for(Obstacle o: obstacles) {
				brush.setColor(Color.BLUE);
				o.paint(brush); 

			}

			brush.setColor(Color.white);
			for(Tokens t : tokensGood) {
				t.paint(brush);
			}

			brush.setColor(Color.RED);
			for(Tokens t : tokensBad) {
				t.paint(brush);
			}

			if(counter % 200 == 0) {
				tokensBad = generateTokens();
				
			}
			
			if(counter % 500 == 0) {
				obstacles = generateObstacle();
			}

			if(counter % 400 == 0) {
				tokensGood = generateTokens();
			}


			score.updateScore();
		} else {
			brush.setColor(Color.black);
			brush.fillRect(0,0, width, height);
			brush.setColor(Color.white);
			brush.drawString("Game Over!", 450, 250);
			brush.drawString("Your Score: " + score.getScore(), 445, 350);
		}
	}

	public static void main (String[] args) {
		ShipGame a = new ShipGame();
		a.repaint();
	}



	public Tokens[] generateTokens() {
		int randomX, randomY;
		int randomNum = (int) (Math.random() * 10) + 5;

		Point [] tokenPoint = new Point[4];
		tokenPoint[0] = new Point(0,0);
		tokenPoint[1] = new Point(20,0);
		tokenPoint[2] = new Point(20,20);
		tokenPoint[3] = new Point(0, 20);

		Tokens[] things = new Tokens[randomNum];

		for(int i = 0; i < randomNum; i++) {
			randomX = (int) (Math.random() * (900) + 50);
			randomY = (int)(Math.random() * (900) + 50);
			things[i] = new Tokens(tokenPoint, new Point(randomX, randomY), 0);
		}
		return things;
	}

	public Obstacle[] generateObstacle() {
		int randomX, randomY;
		int randomNum = (int) (Math.random() * 15) + 5;

		Point [] obstaclePoint = new Point[4];
		obstaclePoint[0] = new Point(0,0);
		obstaclePoint[1] = new Point(10,0);
		obstaclePoint[2] = new Point(10,10);
		obstaclePoint[3] = new Point(0, 10);

		Obstacle[] things = new Obstacle[randomNum];

		for(int i = 0; i < randomNum; i++) {
			randomX = (int) (Math.random() * (900) + 50);
			randomY = (int)(Math.random() * (900) + 50);
			things[i] = new Obstacle(obstaclePoint, new Point(randomX, randomY), 0);
		}

		return things;
	}

	ShipGameInterface shipGame = new ShipGameInterface() {
		@Override
		public boolean collision(Ship s, Tokens[] tokens) {
			for(Tokens t : tokens) {
				for(Point ship : s.getPoints()) {
					if(t.contains(ship)) {
						t.updatePosition();
						return true;
					}
				}
			}
			return false;
		}
	};

	ShipGameInterface collision = (s, tokens) ->{
		for(Tokens t : tokens) {
			for(Point ship : s.getPoints()) {
				if(t.contains(ship)) {
					t.updatePosition();
					return true;
				}
			}
		}
		return false;
	};
	
	ObstacleInterface obstacle = new ObstacleInterface() {
		@Override
		public boolean collideObstacle(Ship s) {
			for(Obstacle o : obstacles) {
				for(Point ship : s.getPoints()) {
					if(o.contains(ship)) {
						return true;
					}
				}
			}
			return false;
		}
	};
	
	//Lambda expression that deals with Obstacle Collision.
	ObstacleInterface obstacleCollision = (s) -> {
		for(Obstacle o : obstacles) {
			for(Point ship : s.getPoints()) {
				if(o.contains(ship)) {
					return true;
				}
			}
		}
		return false;
	};

	private class Score {
		private int score = 0;

		public void updateScore() {
			if(collision.collision(user, tokensGood)) {
				score++;
			} else if(collision.collision(user, tokensBad)) {
				score--;
			}
		}

		public int getScore() {
			if(score < 0) {
				score = 0;
			}

			return score;
		}

	}

	private class EndGame{
		
		public boolean isGameOver = false;
		
		public EndGame() {
			isGameOver = false;
		}
		
		public void isGameOver() {
			if(obstacleCollision.collideObstacle(user)) {
				isGameOver = true;
			} else if(counter/100 > 30){
				isGameOver = true;
			}
		}
		
		public boolean getGameOver() {
			return isGameOver;
		}
	}

}
